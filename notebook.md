# c++知识点
## 网络
### [关键词：TCP、UDP、三次握手、四次挥手、TCP黏包]
#### Q: TCP首部：
1. **源端口号（16位）** **目的端口号（16位）**
2. **序号（32位）** *用来标识TCP发端向TCP收端发送的数据字节流*
3. **确认号（32位）** *由于该报文为SYN报文，ACK标志为0，故没有确认序号（ACK标志为1时确认序号才有效）一旦连接建立，该值将始终发送（同ACK标志）*
4. **数据偏移（4位）** *报头不包含任何任选字段则长度为20字节；4位所能表示的最大值为1111，转化为10进制为15，== 60，故报头最大长度为60字节.*  **保留（6位）** **TCPflag（6位**：**URG** *紧急指针有效性标志*、**ACK** *确认序号有效性标志，一旦一个连接建立起来，该标志总被置为1*、**PSH** *Push标志*、**RST** *重置连接标志*、**SYN** *同步序号标志*、**FIN** *传输数据结束标志*）**窗口（16位）** *TCP流量控制通过连接的每一端声明窗口大小进行控制（接收缓冲区大小）*
5. **检验和 （16位）** *检验和覆盖整个TCP报文段；强制字段，由发送端计算存储，由接收端进行验证* **紧急指针（16位）** *当Urgent标志置1时，紧急指针才有效*
6. TCP选项

#### Q：简述三次握手过程:   
1. 客户端发送 SYN 给服务器，说明客户端请求建立连接；   
2. 服务端收到客户端发的 SYN，并回复 SYN+ACK 给客户端（同意建立连接）；   
3. 客户端收到服务端的 SYN+ACK 后，回复 ACK 给服务端（表示客户端收到了服务端发的同意报文）；服务端收到客户端的 ACK，连接已建立，可以数据传输。   

#### Q：为什么要进行三次握手？
1. 因为信道不可靠，而 TCP 想在不可靠信道上建立可靠地传输，那么三次通信是理论上的最小值。（而 UDP 则不需建立可靠传输，因此 UDP 不需要三次握手。）
2. 因为双方都需要确认对方收到了自己发送的序列号，确认过程最少要进行三次通信。
3. 为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误或资源浪费。

#### Q：TCP两次握手可以不？第三次握手可以传输数据吗？
1. 两次握手可能产生“已失效的连接请求报文段突然又传送到了服务端，因而产生错误或资源浪费”的问题。
2. TCP标准规定，第三次握手的报文，可以携带数据。
TFO工作原理

    > 客户端发送SYN包，包尾加一个FOC请求，只有4个字节。

    > 服务端受到FOC请求，验证后根据来源ip地址声称cookie(8个字节)，将这个COOKIE加载SYN+ACK包的末尾发送回去。

    > 客户端缓存住获取到的Cookie 可以给下一次使用。

    > 下一次请求开始，客户端发送SYN包，这时候后面带上缓存的COOKIE，然后就是正式发送的数据。

   > 服务器端验证COOKIE正确，将数据交给上层应用处理得到相应结果，然后在发送SYN+ACK时，不再等待客户端的ACK确认，即开始发送相应数据。
#### Q：简述四次挥手过程：
1. 客户端发送 FIN 给服务器，说明客户端不必发送数据给服务器了（请求释放从客户端到服务器的连接）；
2. 服务器接收到客户端发的 FIN，并回复 ACK 给客户端（同意释放从客户端到服务器的连接）；客户端收到服务端回复的 ACK，此时从客户端到服务器的连接已释放（但服务端到客户端的连接还未释放，并且客户端还可以接收数据）；服务端继续发送之前没发完的数据给客户端；
3. 服务端发送 FIN+ACK 给客户端，说明服务端发送完了数据（请求释放从服务端到客户端的连接，就算没收到客户端的回复，过段时间也会自动释放）；
4. 客户端收到服务端的 FIN+ACK，并回复 ACK 给客户端（同意释放从服务端到客户端的连接）；服务端收到客户端的 ACK 后，释放从服务端到客户端的连接。

#### Q：为何四次挥手?
1. 因为 TCP 是全双工模式，客户端请求关闭连接后，客户端向服务端的连接关闭（一二次挥手），服务端继续传输之前没传完的数据给客户端（数据传输），服务端向客户端的连接关闭（三四次挥手）。所以 TCP 释放连接时服务器的 ACK 和 FIN 是分开发送的（中间隔着数据传输），而 TCP 建立连接时则没有中间的数据传输服务器的 ACK 和 SYN 是一起发送的（第二次握手），所以 TCP 建立连接需要三次，而释放连接则需要四次。

#### Q：为什么客户端释放最后需要 TIME-WAIT 等待 2MSL 呢？
1. 为了保证客户端发送的最后一个 ACK 报文能够到达服务端。若未成功到达，则服务端超时重传 FIN+ACK 报文段，客户端再重传 ACK，并重新计时。
2. 防止已失效的连接请求报文段出现在本连接中。TIME-WAIT 持续 2MSL 可使本连接持续的时间内所产生的所有报文段都从网络中消失，这样可使下次连接中不会出现旧的连接报文段。
#### Q:大量TIME_WAIT造成的影响：
- 在高并发短连接的TCP服务器上，当服务器处理完请求后立刻主动正常关闭连接。这个场景下会出现大量socket处于TIME_WAIT状态。如果客户端的并发量持续很高，此时部分客户端就会显示连接不上。

#### Q:如何尽量处理TIMEWAIT过多?
- 打开系统的TIMEWAIT重用和快速回收。打开系统的TIMEWAIT重用和快速回收。
1. 修改TIME_WAIT连接状态的上限值
2. 启动快速回收机制
3. 开启复用机制
4. 修改短连接为长连接方式
5. 由客户端来主动断开连接
#### Q:TCP 如何保证可靠传输:
1. 确认和超时重传：
    - TCP 的发送方在规定的时间内没有收到确认就要重传已发送的报文段。这种重传的概念是很简单的，但重传时间的选择却是 TCP 最复杂的问题之一由于 TCP 的下层是互联网环境，发送的报文段可能只经过一个高速率的局域网，也可能经过多个低速率的网络，并且每个 IP 数据报所选择的路由还可能不同。如果把超时重传时间设置得太短，就会引起很多报文段的非必要的重传，使网络负荷增大。但若把超时重传时间设置的过长，则又使网络的空闲时间增大，减低了传输效率。
    - TCP TCP采用经典算法RTT自适应地计算超时重传时间。
2. 数据合理分片和排序
3. 流量控制：利用可变窗口进行流量控制，让发送方的发送速率不要太快，要让接收方来得及接收。
4. 拥塞控制：慢开始( slow-start )、拥塞避免( congestion avoidance )、快重传( fast retransmit )、快恢复( fast recovery )防止过多的数据注入到网络中，使网络中的路由器或链路不致过载
5. 数据校验
#### Q：UDP如何实现可靠？
- 要使用UDP来构建可靠的面向连接的数据传输，就要实现类似于TCP协议的超时重传，有序接受，应答确认，滑动窗口流量控制等机制，等于说要在传输层的上一层（或者直接在应用层）实现TCP协议的可靠数据传输机制，比如使用UDP数据包+序列号，UDP数据包+时间戳等方法，在服务器端进行应答确认机制，这样就会保证不可靠的UDP协议进行可靠的数据传输

#### Q：TCP与UDP的区别：
1. TCP 面向连接,传输的单位是报文段，UDP 是无连接的,传输的单位是用户数据报；
2. TCP 提供可靠的服务，也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP 尽最大努力交付，即不保证可靠交付
3. TCP 的逻辑通信信道是全双工的可靠信道；UDP 则是不可靠信道
4. 每一条 TCP 连接只能是点到点的；UDP 支持一对一，一对多，多对一和多对多的交互通信
5. TCP 面向字节流（可能出现黏包问题），实际上是 TCP 把数据看成一连串无结构的字节流；UDP 是面向报文的（不会出现黏包问题）
6. UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 IP 电话，实时视频会议等）
7. TCP 首部开销20字节；UDP 的首部开销小，只有 8 个字节

#### Q：TCP 是一个基于字节流的传输服务（UDP 基于报文的），“流” 意味着 TCP 所传输的数据是没有边界的。所以可能会出现“粘包”问题。
1. 发送定长包。如果每个消息的大小都是一样的，那么在接收对等方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。
2. 包头加上包体长度。包头是定长的 4 个字节，说明了包体的长度。接收对等方先接收包头长度，依据包头长度来接收包体。
3. 在数据包之间设置边界，如添加特殊符号 \r\n 标记。FTP 协议正是这么做的。但问题在于如果数据正文中也含有 \r\n，则会误判为消息的边界。
4. 使用更加复杂的应用层协议。

#### Q：状态码（Status-Code）：
1. 1xx：表示通知信息，如请求收到了或正在进行处理
    - 100 Continue：继续，客户端应继续其请求
    - 101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议
2. 2xx：表示成功，如接收或知道了
    - 200 OK: 请求成功
3. 3xx：表示重定向，如要完成请求还必须采取进一步的行动
    - 301 Moved Permanently: 永久移动。请求的资源已被永久的移动到新 URL，返回信息会包括新的 URL，浏览器会自动定向到新 URL。今后任何新的请求都应使用新的 URL 代替
4. 4xx：表示客户的差错，如请求中有错误的语法或不能完成
    - 400 Bad Request: 客户端请求的语法错误，服务器无法理解
    - 401 Unauthorized: 请求要求用户的身份认证
    - 403 Forbidden: 服务器理解请求客户端的请求，但是拒绝执行此请求（权限不够）
    - 404 Not Found: 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置 “您所请求的资源无法找到” 的个性页面
    - 408 Request Timeout: 服务器等待客户端发送的请求时间过长，超时
5. 5xx：表示服务器的差错，如服务器失效无法完成请求
    - 500 Internal Server Error: 服务器内部错误，无法完成请求
    - 503 Service Unavailable: 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的 Retry-After 头信息中
    - 504 Gateway Timeout: 充当网关或代理的服务器，未及时从远端服务器获取请求
#### QUIC 与现有 TCP + TLS + HTTP/2 方案相比，有以下几点主要特征：
1. 利用缓存，显著减少连接建立时间；
2. 改善拥塞控制，拥塞控制从内核空间到用户空间；
3. 没有 head of line 阻塞的多路复用；
4. 前向纠错，减少重传；
5. 连接平滑迁移，网络状态的变更不会影响连接断线。
#### Q：网络传输结构体有什么注意的地方？
1. 字节对齐，可以考虑用#pragma pack(1)处理；还有字节序，可以都考虑用htonl和htons处理，都转成大端的；推荐用序列化。

#### Q：视频协议？
1. RTMP、RTSP、HLS（RTMP、HTTP-FLV 和 HLS 三大直播协议）
#### Q：网络分层:
<table>
	<tr>
		<td>OSI7层</td>
		<td>TCP/IP 4层</td>
        <td>5层协议</td>
	<tr>
	<tr>
        <td>应用层</td>
        <td rowspan="5">应用层</td>
        <td rowspan="5">应用层</td>
	<tr>
    <tr>
        <td>表示层</td>
	<tr>
    <tr>
        <td>会话层</td>
	<tr>
    <tr>
        <td>运输层</td>
		<td>运输层（TCP或UDP）</td>
        <td>运输层</td>
	<tr>
    <tr>
        <td>网络层</td>
		<td>网际层</td>
        <td>网络层</td>
	<tr>
    <tr>
        <td>数据链路层</td>
		<td rowspan="3">网络接口层</td>
        <td>数据链路层</td>
	<tr>
    <tr>
        <td>物理层</td>
        <td>物理层</td>
	<tr>
</table>

---
## 数据结构与算法
#### Q：十大排序算法：  
排序算法|	平均时间复杂度|	最差时间复杂度|	空间复杂度|	数据对象稳定性
-|-|-|-|-
冒泡排序|	O(n2)|	O(n2)|	O(1)	|稳定
选择排序|	O(n2)|	O(n2)|	O(1)	|数组不稳定、链表稳定
插入排序|	O(n2)|	O(n2)|	O(1)	|稳定
快速排序|	O(n*log2n)|	O(n2)|	O(log2n)|	不稳定
堆排序|	O(n*log2n)|	O(n*log2n)|	O(1)|	不稳定
归并排序|	O(n*log2n)|	O(n*log2n)|	O(n)|	稳定
希尔排序|	O(n*log2n)|	O(n2)|	O(1)|	不稳定
计数排序|	O(n+m)|	O(n+m)|	O(n+m)	|稳定
桶排序|	O(n)|	O(n)|	O(m)|	稳定
基数排序|	O(k*n)|	O(n2)	||	稳定

#### Q：STL共有六大组件:
1. 容器（Container）
    - 序列式容器
        - vector-数组：元素不够时再重新分配内存，拷贝原来数组的元素到新分配的数组中。iterator支持 ”+“、”+=“，”<"等操作。
        - list－双链表：一个环状双向链表，在内存中不一定连续，不支持随机访问，iterator不支持 ”+“、”+=“，”<"等操作。
        - deque 双端队列：分配中央控制器map(并非map容器)，map记录着一系列的固定长度的数组的地址.记住这个map仅仅保存的是数组的地址,真正的数据在数组中存放着.deque先从map中央的位置(因为双向队列，前后都可以插入元素)找到一个数组地址，向该数组中放入数据，数组不够时继续在map中找空闲的数组来存数据。当map也不够时重新分配内存当作新的map,把原来map中的内容copy的新map中。所以使用deque的复杂度要大于vector，尽量使用vector。
        - stack 栈：先进后出，基于deque
        - queue 队列：先进先出，只能在容器的末尾添加新元素，只能从头部移除元素，基于deque
        - heap 堆：完全二叉树，使用最大堆排序，以数组(vector)的形式存放。【make_heap】在容器范围内，就地建堆，保证最大值在所给范围的最前面，其他值的位置不确定【pop_heap】将堆顶(所给范围的最前面)元素移动到所给范围的最后，并且将新的最大值置于所给范围的最前面【push_heap】当已建堆的容器范围内有新的元素插入末尾后，应当调用push_heap将该元素插入堆中。
        - priority_queue 优先队列：基于heap
        - slist 单向链表
    - 关联式容器
        - set（Set结构是类似于数组结构,但是成员都是不重复的值）：红黑树，插入、删除、查找 O(log2n)，有序，不可重复。
        - map（Map结构是键值对集合(Hash结构)）：
            - 红黑树，插入、删除、查找 O(log2n)，有序，不可重复。
            - 使用insert()插入元素的方式并不能覆盖掉相同key的值（放弃插入）；而使用[]方式则可以覆盖掉之前的值。
        - multiset
        - multimap（基于红黑树(RB-tree)，一种加上了额外平衡条件的二叉搜索树）
        - hash table散列表
            - 如何解决hash冲突问题?
                1. **链地址法**：key 相同的用单链表链接
                2. **开放定址法**
                    - 线性探测法：key 相同 -> 放到 key 的下一个位置，Hi = (H(key) + i) % m
                    - 二次探测法：key 相同 -> 放到 Di = 1^2, -1^2, ..., ±（k)^2,(k<=m/2）
                    - 随机探测法：H = (H(key) + 伪随机数) % m
                3. **再哈希法** 就是同时构造多个不同的哈希函数：当H1 = RH1(key) 发生冲突时，再用H2 = RH2(key) 进行计算，直到冲突不再产生，这种方法不易产生聚集，但是增加了计算时间
                4. 建立**公共溢出区**将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区

            - hash_map,hash_set,hash_multiset,hash_multimap-基于hash table

map| unordered_map
-|-
map内部实现了一个红黑树|unordered_map内部实现了一个哈希表
map的有序性：红黑树（非严格平衡二叉树），该结构具有自动排序的功能，因此map内部的所有元素都是有序的|unordered_map的无序性：哈希表不会根据key值大小进行排序，存储时是根据key的hash值判断元素是否相同，因此unordered_map内部元素是无序的。
map的运行效率：红黑树可以在O(log n)时间内做查找，插入和删除，这里的n是树中元素的数目 | unordered_map的运行效率：哈希表的查找的时间复杂度可达到O(1)
map内存占用比低|unordered_map内存占用比高
---

2. 算法（Algorithm）
3. 迭代器（Iterator）
4. 仿函数（Function object）
5. 适配器（Adaptor）
6. 空间配置器（allocator）

#### Q：为什么windows vector是1.5倍，linux是2倍？
1. 采用采用成倍方式扩容，可以保证常数的时间复杂度，而增加指定大小的容量只能达到O(n)的时间复杂度，因此，使用成倍的方式扩容
2. k = 1.5 在几次扩展之后，可以重用之前的内存空间。
3. 最佳可能为1.618？
#### Q：递归迭代区别优缺点？
1. 递归：
    - 【优点】
        - 1）大问题化为小问题,可以极大的减少代码量；
        - 2）用有限的语句来定义对象的无限集合.；
        - 3）代码更简洁清晰，可读性更好
    - 【缺点】
        - 1）递归调用函数,浪费空间；
        - 2）递归太深容易造成堆栈的溢出；
2. 迭代：
    - 【优点】
        - 1）迭代效率高，运行时间只因循环次数增加而增加；
        - 2）没什么额外开销，空间上也没有什么增加
    - 【缺点】
        - 1） 不容易理解；
        - 2） 代码不如递归简洁；
        - 3） 编写复杂问题时困难。
#### Q:红黑树的特征是什么？
1. 节点是红色或黑色。
2. 根是黑色。
3. 所有叶子都是黑色（叶子是 NIL 节点）。
4. 每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）（新增节点的父节点必须相同）
5. 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。（新增节点必须为红）

---
## c++
### 关键词
#### explicit关键词
1. explicit 修饰构造函数时，可以防止隐式转换和复制初始化
2. explicit 修饰转换函数时，可以防止隐式转换，但 按语境转换 除外

#### Q： 说一下 static 关键字的作用
1. 全局静态变量：在全局变量前加上关键字static就定义成一个全局静态变量，存在静态存储区，在整个程序运行期间一直存在。未经初始化的全局静态变量会被自动初始化为0，全局静态变量在声明他的文件之外是不可见的。
2. 局部静态变量：在局部变量之前加上关键字static就成为一个局部静态变量，存在静态存储区，未经初始化的全局静态变量会被自动初始化为0，作用域仍为局部作用域，但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，若该函数再次被调用，其值未变。
3. 静态函数：在函数返回类型前加static，函数就定义为静态函数。从而不能被其他文件可用，也不会同其他cpp中的同名函数引起冲突。
4. 类的静态成员：在类中静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。对多个对象来说，静态数据成员只存储一处，供所有对象共用。
5. 类的静态函数：静态成员函数和静态数据成员一样属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：<类名>::<静态成员函数名>(<参数表>)。

#### Q: extern 关键字
1. 被 extern 限定的函数或变量是 extern 类型的
2. 被 extern "C" 修饰的变量和函数是按照 C 语言方式编译和链接的, 可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。
3. extern "C" 使用
```c++
#ifdef __cplusplus
extern "C" {
#endif

void *memset(void *, int, size_t);

#ifdef __cplusplus
}
#endif
```
#### Q: 二维数组哪一维可以省略，为什么，三维数组呢?
- 可以省略第一维的定义，但不能省略第二维的定义。系统根据初始化的数据个数和第2维的长度可以确定第一维的长度。inta[ ][3]={1,2，3，4，5，6};例如a数组的第一维的定义被省略，初始化数据共6个，第二维的长度为3，即每行3个数，所以a数组的第一维是2。三维也是一样啊。若第二维也省了不就退化为二维了么。。

#### Q：如何得到结构体中某个变量的偏移量
- A：创建宏：
```c++
#define OFFSET(structure, member) ((int64_t)&((structure*)0)->member) // 64位系统   
#define OFFSET(structure, member) ((int32_t)&((structure*)0)->member) // 32位系统
```
### 内存管理
#### Q: 程序进程中的分区：

相关概念：堆(heap)，栈(stack)，BSS段，数据段(data)，代码段(code /text)，全局静态区，文字常量区，程序代码区。 
  由低到高地址依次为：
1. 程序代码区：存放函数体的二进制代码。
2. 全局区静态区：
    - 文字常量区—常量字符串
    - 数据段（data segment）- 存放程序中已初始化的全局变量、静态初始化数据。
    - BSS段（bss segment）- 未初始化的全局变量、静态未初始化数据。
3. 堆（heap）：堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。向上增长。
5. 栈(stack)：栈又称堆栈，函数参数、返回值、局部变量。由于栈的后进先出特点，所以栈特别方便用来保存/恢复调用现场，向下增长，速度快。


#### new 跟 malloc的差别
1. new 是运算符 malloc是库函数 
2. new和delete底层还是由malloc和free实现的，区别在于new和delete在生成复杂数据类型时会执行两步:分配内存和调用构造函数/调用析构函数和销毁内存。
3. malloc申请的内存没有类型为(void*)需要根据使用需求进行强制转换,new不需要。
4. new并不是每次都会调用构造函数，对于简单类型eg.int是不需要的。PS:  定位 new（placement new）允许我们向 new 传递额外的地址参数，从而在预先指定的内存区域创建对象。

#### Q: C++源文本到可执行文件需要经历哪些阶段
1. 预处理（产生.i文件，-E）
    - 主要处理那些源代码文件中以“#”开始的预处理指令，主要规则如下：
        - 将#define删除，宏定义展开。
        - 处理预编译指令如#ifndef,#ifdef,#elif,#else,#endif等。将不必要的代码过滤掉。
        - 处理#include预编译指令，将被包含的文件插入到该预编译指令的位置。这个过程是递归进行的，因为被包含的文件可能也包含其他文件。
        - 过滤掉所有注释/**/和//里面的内容。
        - 另外还会添加行号和文件名标识。
        - 最后会保留#pragma编译器指令，因为编译器需要使用它们。   
        1、面试题--->#ifndef,#ifdef,#endif的作用？   
        2、面试题--->#include尖括号和双引号的区别？
2. 编译（产生.s文件，-s）:
    - 将预处理的文件进行一系列的词法分析，语法分析，语义分析，以及优化后产生相应的汇编代码文件
3. 汇编（产生.o或.obj文件，-c）:
    - 把汇编语言代码翻译成目标机器指令的过程，即生成目标文件
4. 链接（产生.out或.exe文件，-o）:
    - 将目标文件和库一起链接形成最终可执行文件。链接主要解决的是源代码之间的相互依赖问题，链接的过程包括地址和空间的分配，符号决议，和重定位等这些步骤   
    1、静态链接/库
    2、动态链接/库
#### Q: 类和结构体有什么区别（属性还有什么区别 struct可以进行模板参数吗？）
1. 在C++出现的时候为了兼容C语言，保留了结构体的概念，但是对结构体做了扩展。C++中的结构体不仅可以包含数据成员，还可以包含方法成员，因此从构成的角度来讲，类和结构体没有区别。
2. 访问权限，在定义时如果没有显式地使用访问限定符，类中默认是private成员，而结构体中默认是public成员。类和结构体除了默认的成员访问权限不同之外，没有其他区别。
3. C++里面的struct是可以使用template的
#### Q: 野指针是什么、怎么出现的
1. 是什么：野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）指针。
2. 危害：
    - 由于其指向的地址是不确定的，解引用一个不确定的地址，所得结果是不可知的。现在的cpu和操作系统已经不允许用户程序指向它外部的内存了，所以野指针一般只能搞坏自己一个进程。
    - 不能通过指针判空去识别一个指针是否为野指针查找困难。
3. 成因：
    - 指针变量的值未被初始化： 声明一个指针的时候，没有显示的对其进行初始化，那么该指针所指向的地址空间是乱指一气的。
    - 指针所指向的地址空间已经被free或delete：在堆上malloc或者new出来的地址空间，如果已经free或delete，那么此时堆上的内存已经被释放，但是指向该内存的指针如果没有人为的修改过，那么指针还会继续指向这段堆上已经被释放的内存，这时还通过该指针去访问堆上的内存，就会造成不可预知的结果
    - 指针操作超越了作用域（如栈内存在函数结束时会被释放）：
4. 避免：delete了一个指向动态对象的指针后，及时置为NULL。相应的，对指针进行解除引用前，判断指针是否为NULL。
#### Q: 哪些情形会导致内存泄漏，如何避免呢
C++的内存泄漏，即是new出来的内存没有通过delete合理的释放掉。
1. 在类的构造函数和析构函数中没有匹配的调用new和delete函数：
    - 在堆里创建了对象占用了内存，但是没有显示地释放对象占用的内存；
    - 在类的构造函数中动态的分配了内存，但是在析构函数中没有释放内存或者没有正确的释放内存
2. 没有正确地清除嵌套的对象指针
    - 指向对象的指针数组不等同于对象数组：   
    数组中存放的是指向对象的指针，不仅要释放每个对象的空间，还要释放每个指针的空间，delete []p只是释放了每个指针，但是并没有释放对象的空间，正确的做法，是通过一个循环，将每个对象释放了，然后再把指针释放了。
3. 在释放对象数组时在delete中没有使用方括号
4. 缺少拷贝构造函数：
    - 如果没有定义拷贝构造函数，编译器会调用默认的拷贝构造函数，逐个成员拷贝的方式来复制数据成员，如果以逐个成员拷贝的方式来复制指针，结果就是两个对象拥有指向同一个动态分配的内存空间的指针。当释放第一个对象的时候，它的析构函数就会释放与该对象有关的动态分配的内存空间。而释放第二个对象的时候，它的析构函数会释放相同的内存，这样是错误的。
    - 如果一个类里面有指针成员变量，要么必须显示的写拷贝构造函数和重载赋值运算符，要么禁用拷贝构造函数和重载赋值运算符
5. 缺少重载赋值运算符
    - 这种问题跟上述问题类似，也是逐个成员拷贝的方式复制对象。
6. 没有将基类的析构函数定义为虚函数
    - 当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露
### **智能指针**
- C++ 标准库（STL）中
头文件：```#include <memory>```
1. shared_ptr
    - 多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。
    - 支持定制型删除器（custom deleter），可防范 Cross-DLL 问题（对象在动态链接库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁）、自动解除互斥锁
    - shared_ptr在对计数器进行修改的时候需要加锁实现线程安全
2. weak_ptr 
    - 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会**自动成空**（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。
    - 可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题
3. unique_ptr
    - unique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。
    - unique_ptr 用于取代 auto_ptr
4. auto_ptr （被 C++11 弃用）
    - C++ 98   
    ```std::auto_ptr<std::string> ps (new std::string(str))；```
    - 被 c++11 弃用，原因是缺乏语言特性如 “针对构造和赋值” 的 std::move 语义，以及其他瑕疵。
5. auto_ptr 与 unique_ptr 比较
    - auto_ptr 可以赋值拷贝，复制拷贝后所有权转移；unqiue_ptr 无拷贝赋值语义，但实现了move 语义；
    - auto_ptr 对象不能管理数组（析构调用 delete），unique_ptr 可以管理数组（析构调用 delete[] ）；
#### Q: 析构函数为什么必须是虚函数？
1. 将可能会被继承的父类的析构函数设置为虚函数，可以保证当我们new一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。
2. C++**默认的析构函数不是虚函数，是因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存**。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。因此C++默认的析构函数不是虚函数，而是只有当需要当作父类时，设置为虚函数


#### Q:虚函数、纯虚函数区别：
1. 类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖（override），这样的话，编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。
2. 虚函数在子类里面可以不重写；但纯虚函数必须在子类实现才可以实例化子类。
3. 虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。纯虚函数关注的是接口的统一性，实现由子类完成。
4. 带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类被继承后，子类可以继续是抽象类，也可以是普通类。
5. 虚基类是虚继承中的基类，具体见下文虚继承。
```c++
class Father
{
public:
　　virtual void func_1(){}　　  //虚函数
　　virtual void func_2()=0;　　//纯函数
}
class Child
{
public:
　　void func_1();　　　　//可重写，也可不，重写格式可以和父类不同
　　void func_2();　　　　//必须重写，而且格式必须和父类保持一致
}
```
#### Q: 介绍下虚函数
1. 虚函数作用：
    - 实现动态多态
    - 动态多态实现条件：
        - 基类中必须存在虚函数，派生类必须重写虚基类中的虚函数。通过基类对象的指针或引用来调用虚函数。
2. 虚函数原理
    - 编译器给每个对象添加一个指针（虚表指针），指向虚函数表，虚函数表存储了为类对象进行声明的虚函数的地址。
    - 如基类对象会包含这个指针，指向基类所有虚函数的地址表，派生类对象也会包含这样一个指针（指向派生类虚表） ，若派生类提供了虚函数的新定义，该虚表将保存新函数的地址，如果派生类没有重新定义虚函数，则该虚表将保存函数原始版本的地址。若派生类定义了新的虚函数，则该函数的地址将被添加到虚函数表中，注意虚函数无论多少个都只需要在对象中添加一个虚表指针。
    - 当调用虚函数时，程序将查看对象中的虚表指针，转向相应的虚表，使用类声明中定义的第几个虚函数，程序就使用数组的第几个函数地址，并执行该函数。
#### Q：什么是纯虚函数？
- 纯虚函数是一种特殊的虚函数，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。
```virtual int A() = 0;```

#### Q：虚继承是什么
1. 虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。
2. 底层实现原理与编译器相关，一般通过虚基类指针和虚基类表实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。
3. 实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。

#### Q：虚函数和虚继承有何区别？
1. 虚函数继承和虚继承是完全不同的两个概念。
2. 相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）
3. 不同之处：
    - 虚继承
        - 虚基类依旧存在继承类中，只占用存储空间
        - 虚基类表存储的是虚基类相对直接继承类的偏移
    - 虚函数
        - 虚函数不占用存储空间
        - 虚函数表存储的是虚函数地址

#### Q: 常用的多态有哪几种方式
同一个事物在不同场景下的多种形态：    
1. 静态多态（编译期/早绑定）：静态多态是编译器在编译期间完成的，函数重载，编译器会根据实参类型来选择调用合适的函数，如果有合适的函数可以调用就调，没有的话就会发出警告或者报错。
2. 动态多态（运行期期/晚绑定）虚函数，用 virtual 修饰成员函数，使其成为虚函数

#### Q: 重载和虚函数的区别
1. 重载函数在类型和参数数量上一定不相同，而重定义的虚函数则要求参数的类型和个数、函数返回类型相同；
2. 虚函数必须是类的成员函数，重载的函数则不一定是这样；
3. 构造函数可以重载，但不能是虚函数，析构函数不可以被重载，析构函数可以是虚函数。

[关键词：内存管理、分区]
#### Q: C++的内存管理，分哪些区，作用。哪些是线程私有的哪些是线程共有的。
A: 内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。   
栈，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。

　　堆，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。

　　自由存储区，就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。

　　全局/静态存储区，全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。

　　常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。
- - -
#### Q:内存泄露怎么测试出来?
1. linux下Valgrind、 asan工具
2. windows下使用函数_CrtDumpMemoryLeaks

#### Q:coredump是怎么回事？
1. 当程序运行的过程中异常终止或崩溃，操作系统会将程序当时的内存状态记录下来，保存在一个文件中，这种行为就叫做Core Dump（中文有的翻译成“核心转储”)。我们可以认为 core dump 是“内存快照”，但实际上，除了内存信息之外，还有些关键的程序运行状态也会同时 dump 下来，例如寄存器信息（包括程序指针、栈指针等）、内存管理信息、其他处理器和操作系统状态和信息。core dump 对于编程人员诊断和调试程序是非常有帮助的，因为对于有些程序错误是很难重现的，例如指针异常，而 core dump 文件可以再现程序出错时的情景。
2. ```ulimit -c``` 输出为0 表明关闭core dump异常终止时不会生成。可通过```ulimit -c unlimited```开启。

#### Q:怎么找到占用内存很大代价的进程
1. 方法1：```ps -aux | sort -k4nr | head -K```   
如果是10个进程，K=10，如果是最高的三个，K=3
说明：ps -aux中（a指代all——所有的进程，u指代userid——执行该进程的用户id，x指代显示所有程序，不以终端机来区分）

    - ps -aux的输出格式如下：
```
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.0  19352  1308 ?        Ss   Jul29   0:00 /sbin/init
root         2  0.0  0.0      0     0 ?        S    Jul29   0:00 [kthreadd]
root         3  0.0  0.0      0     0 ?        S    Jul29   0:11 [migration/0]
```
    - ort -k4nr中（k代表从第几个位置开始，后面的数字4即是其开始位置，结束位置如果没有，则默认到最后；n指代numberic sort，根据其数值排序；r指代reverse，这里是指反向比较结果，输出时默认从小到大，反向后从大到小。）。本例中，可以看到%MEM在第4个位置，根据%MEM的数值进行由大到小的排序。
    head -K（K指代行数，即输出前几位的结果）
    |为管道符号，将查询出的结果导到下面的命令中进行下一步的操作。

2. 方法2：top （然后按下M，注意大写）

#### Q:可以使用下面命令查使用CPU最多的K个进程

1. 方法1：

```ps -aux | sort -k3nr | head -K```
2. 方法2：top （然后按下P，注意大写)

#### Q：为什么-9可以杀死进程
- kill是给某个进程id发送一个信号。默认发送的信号是SIGTERM（终止进程），而kill -9发送的信号是SIGKILL（无条件终止），即exit。exit信号不会被系统阻塞，所以kill -9能顺利杀掉进程。
#### Q：GDB用法
- A：参数列表：

| 命令 | 命令缩写 | 命令说明 |     
-|-|-|
| list | l | 显示多行源代码 |
|break|b|设置断点,程序运行到断点的位置会停下来
|info|i|描述程序的状态
run|r|开始运行程序
display|disp|跟踪查看某个变量,每次停下来都显示它的值
step|s|执行下一条语句,如果该语句为函数调用,则进入函数执行其中的第一条语句
next|n|执行下一条语句,如果该语句为函数调用,不会进入函数内部执行(即不会一步步地调试函数内部语句)
print|p|打印内部变量值
continue|c|继续程序的运行,直到遇到下一个断点
set var name=v||设置变量的值
start|st|开始执行程序,在main函数的第一条语句前面停下来
file||装入需要调试的程序
kill|k|终止正在调试的程序
watch||监视变量值的变化
backtrace|bt|用于回溯函数调用栈(堆栈)
frame|f|查看栈帧
quit|q|退出GDB环境

#### Q：深浅拷贝
1. 是针对指针的，
    - 【浅拷贝】是只拷贝指针地址，意思是浅拷贝指针都指向同一个内存空间，当原指针地址所指空间被释放，那么浅拷贝的指针全部失效。
    - 【深拷贝】是先申请一块跟被拷贝数据一样大的内存空间，把数据复制过去。这样拷贝多少次，就有多少个不同的内存空间，干扰不到对方。
2. 浅拷贝带来问题的本质在于析构函数释放多次堆内存，使用std::shared_ptr，可以完美解决这个问题。


o左值右值
o网络编程
#### Q：IO多路复用的优势，select，poll和epoll区分，epoll为什么快？
1. IO多路复用相比于多线程的优势在于系统的开销小，系统不必创建和维护进程或线程，免去了线程或进程的切换带来的开销。而操作系统支持IO多路复用的系统调用有select，poll和epoll。
2. select 底层是一个fd_set的数据结构，本质上是一个long类型的数组，数组中每一个元素都对应于一个文件描述符，通过轮询所有的文件描述符来检查是否有事件发生。
o【优点】：可移植性好；连接数少并且连接都十分活跃的情况下，效率也不错。
o【缺点】：可以监听的最大文件描述符数量为1024（因为内核写定了）。每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大；检查是否有事件发生是采用轮询遍历的方式，当文件描述符很多时开销很大。
3. poll本质上和select没有区别
o【优点】：1、poll() 不要求开发者计算最大文件描述符加一的大小。2、poll() 在应付大数目的文件描述符的时候速度更快，相比于select。3、它没有最大连接数的限制，原因是它是基于链表来存储的。
o【缺点】：1、大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义；2、与select一样，poll返回后，需要轮询pollfd来获取就绪的描述符。
4. epoll
oselect，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。2、select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。
## 操作系统
#### Q:进程，线程的区别
1. 进程是资源分配的独立单位
    - 进程之间的通信方式以及优缺点
        1. 管道（PIPE）
            - 有名管道：一种半双工的通信方式，它允许无亲缘关系进程间的通信
                - 优点：可以实现任意关系的进程间的通信
                - 缺点：1. 长期存于系统中，使用不当容易出错 2. 缓冲区有限
            - 无名管道：一种半双工的通信方式，只能在具有亲缘关系的进程间使用（父子进程）
                - 优点：简单方便
                - 缺点：1. 局限于单向通信 2.只能创建在它的进程以及其有亲缘关系的进程之间 3. 缓冲区有限
        2. 信号量（Semaphore）：一个计数器，可以用来控制多个线程对共享资源的访问
            - 优点：可以同步进程
            - 缺点：信号量有限
        3. 信号（Signal）：一种比较复杂的通信方式，用于通知接收进程某个事件已经发生
        4. 消息队列（Message Queue）：是消息的链表，存放在内核中并由消息队列标识符标识
            - 优点：可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题，方便
            - 缺点：信息的复制需要额外消耗 CPU 的时间，不适宜于信息量大或操作频繁的场合
        5. 共享内存（Shared Memory）：映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问
            - 优点：无须复制，快捷，信息量大
            - 缺点：1. 通信是通过将共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此进程间的读写操作的同步问题 2. 利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信
        6. 套接字（Socket）：可用于不同计算机间的进程通信
            - 优点：1. 传输数据为字节级，传输数据可自定义，数据量小效率高 2. 传输数据时间短，性能高 3. 适合于客户端和服务器端之间信息实时交互 4. 可以加密,数据安全性强
            - 缺点：需对传输的数据进行解析，转化成应用级的数据。
    - 进程之间私有和共享的资源
        - 私有：地址空间、堆、全局变量、栈、寄存器
        - 共享：代码段，公共数据，进程目录，进程 ID
2. 线程是资源调度的独立单位
    - 线程之间的通信方式, 线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制
        - 锁机制：包括互斥锁/量（mutex）、读写锁（reader-writer lock）、自旋锁（spin lock）、条件变量（condition）
            - 互斥锁/量（mutex）：提供了以排他方式防止数据结构被并发修改的方法。
            - 读写锁（reader-writer lock）：允许多个线程同时读共享数据，而对写操作是互斥的。
            - 自旋锁（spin lock）与互斥锁类似，都是为了保护共享资源。互斥锁是当资源被占用，申请者进入睡眠状态；而自旋锁则循环检测保持者是否已经释放锁。
            - 条件变量（condition）：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。
        - 信号量机制(Semaphore)
            - 无名线程信号量
            - 命名线程信号量
        - 信号机制(Signal)：类似进程间的信号处理
        - 屏障（barrier）：屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行。

    - 线程之间私有和共享的资源
        - 私有：线程栈，寄存器，程序计数器
        - 共享：堆，地址空间，全局变量，静态变量
3. 进程和线程的区别
对比维度|	多进程|	多线程	|总结
-|-|-|-
数据共享、同步|	数据共享复杂，需要用 IPC；数据是分开的，同步简单	|因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂|	各有优势
内存、CPU	|占用内存多，切换复杂，CPU 利用率低|	占用内存少，切换简单，CPU 利用率高	|线程占优
创建销毁、切换|	创建销毁、切换复杂，速度慢	|创建销毁、切换简单，速度很快|	线程占优
编程、调试|	编程简单，调试简单|	编程复杂，调试复杂	|进程占优
可靠性|	进程间不会互相影响	|一个线程挂掉将导致整个进程挂掉	|进程占优
分布式	|适应于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单	|适应于多核分布式	|进程占优
#### Q：什么是协程
- 协程：协程的调度完全由用户控制，实现协作式多任务，可以在程序执行内部中断，转而执行其他协程。比如我们编写子程序（或者说函数），通常是利用“调用”来实现从 A 跳去 B，B 跳去 C，如果想回来调用方，必须等被调用方执行完才行，整个调用过程是通过栈实现的。而协程是运行子程序的过程中“中断”，转而执行其他子程序，再在适当的时候返回来接着运行。

#### Q：协程与线程的区别
- 协程相比于线程的优势： 
    1. 协程效率比线程高。线程间切换需要开销，而协程间切换是由程序自身控制的，不需要开销。 
    2. 协程不需要多线程的锁机制。协程是在一个线程内进行切换，所以不存在同时写变量冲突，不需要给共享资源加锁，只需要判断状态。
    3. PS：如果想使用多CPU的话，可以使用进程+协程。

#### 协程的实现
- （python）协程是通过yield实现的，所以协程是生成器，可以通过 next 调用。

### 死锁
#### Q: 死锁产生的原因、条件、预防
1. 原因：系统资源不足、资源分配不当、进程运行推进顺序不合适
2. 产生条件：互斥、请求和保持、不剥夺、环路
3. 预防：
    - 打破互斥条件：改造独占性资源为虚拟资源，大部分资源已无法改造。
    - 打破不可抢占条件：当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源。
    - 打破占有且申请条件：采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待，这样就不会占有且申请。
    - 打破循环等待条件：实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源。
    - 有序资源分配法
    - 银行家算法
----
## 设计模式
### [关键词：Reactor、RAII]
#### Q:说一下 Reactor 模式

#### Q：书写一个 RAII（“资源获取时机就是初始化时机”）类的原则
1. 最重要的原则是：资源在对象构造期间初始，在析构期间进行释放。
2. 许多时候允许 RAII 对象被复制并不合理。如果不合理则应该对RAII的拷贝操作进行禁止。
3. 对引用计数法的 RAII 对象，我们需要在它的最有一个使用者用完之后进行销毁。复制对象时，应该将资源的被引用数递增。如：shared_ptr
4. 申请的资源我们一定是希望使用这个资源，所以RAII 类要提供对原始资源访问。
5. 对原始资源的访问可能经由显式转换或隐式转换。一般而言显式转换比较安全，但隐式转换对用户比较方便。
- PS 使用最多的可能就是 智能指针 和 互斥锁的使用

#### Q：你用过MVC框架么，能谈谈对它的认识么
1. MVC是三个单词的首字母缩写，它们是Model（模型）、View（视图）和Controller（控制）。
这个模式认为，程序不论简单或复杂，从结构上看，都可以分成三层：
    - 最上面的一层，是直接面向最终用户的"视图层"（View）。它是提供给用户的操作界面，是程序的外壳。
    - 最底下的一层，是核心的"数据层"（Model），也就是程序需要操作的数据或信息。
    - 中间的一层，就是"控制层"（Controller），它负责根据用户从"视图层"输入的指令，选取"数据层"中的数据（分发器角色），然后对其进行相应的操作，产生最终结果。  

    这三层是紧密联系在一起的，但又是互相独立的，每一层内部的变化不影响其他层。每一层都对外提供接口（Interface），供上面一层调用。这样一来，软件就可以实现模块化，修改外观或者变更数据都不用修改其他层，大大方便了维护和升级。
#### Q：知道哪些设计模式
## 手撕题
#### 顺时针打印矩阵 https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/
#### 链表反转：
```c++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        //头插法：
        //1、定义已反转 hadrev 和 未反转 curr（当前要处理）
        //2、头插法（记录下次要处理的节点 nexttemp， 
        // 当前curr 插到已反转 hadrev 之前，
        // 更新已反转 hadrev
        // 更新下次循环的当期处理节点 ）
        ListNode* hadrev = NULL;
        ListNode* curr = head;
        while(curr){
            ListNode* nexttemp = curr->next;
            curr->next = hadrev;
            hadrev = curr;
            curr = nexttemp; 
        }
        return hadrev;
    }
};
```
#### Q：手写strcpy
```c++
char* mystrcpy(char* dst, const char* src)
{
    assert(dst != NULL);
    assert(src != NULL);
    if (dst == src)
        return dst;
    int size = strlen(src) + 1;
    if (dst < src || src + size <= dst)
    {
        char* d = dst;
        const char* s = src;
        while (size--)
            *d++ = *s++;
    }
    else
    {
        char* d = dst + size - 1;
        const char* s = src + size - 1;
        while (size--)
            *d-- = *s--;
    }
    return dst;
}   
```
#### 实现atoi函数
#### Q:实现strstr
- strstr(str1,str2) 函数用于判断字符串str2是否是str1的子串。
```c++
char *strstr(const char *str, const char *sub){
    if (!str || !sub){
        return nullptr;
    }
    char *dest = (char*)str;
    char *src = (char*)sub;
    char *flag = nullptr;
    while(*dest){
        flag = dest;//记录主串的起点
        src = (char*)sub;//记录子串的起点
        //开始匹配
        while(*flag && *src && (*flag == *src)){
            flag++;
            src++;
        }
        //若匹配到子串尾
        if (!*src){
            return dest;
        }
        //反之更新主串的起点
        else{
            dest++;
        }
    }
}
```


#### Q: 讲讲阻塞IO网络通信IO 进程通信 阻塞型IO和非阻塞性IO

（msg：共享内存 管道 是线程通信把？）



算法题：求最长的连续子串 在字典序上连续 要求同等长度取最靠后的 O(n)

算法题：实现map （恐怖如斯）

算法题：实现hashmap的过程讲讲

#### Q: 怎么处理多线程的问题 产生死锁该怎么办

题目大致是这样的。实现map被吓坏了，只能口胡一下红黑树的概念。没项目卑微的瑟瑟发抖。

面向面经复习法还是不太靠谱 ， 看别人的面经问题发现自己都会 ， 自己面试的时候总会有没复习到的。

作者：牛客883396841号
链接：https://www.nowcoder.com/discuss/472040
来源：牛客网

你用过MVC框架，能谈谈对它的认识么
知道哪些设计模式

观察者模式和代理模式的区别

C++中static修饰类中成员和全局变量时的作用

Static修饰局部变量时的作用

什么是内存泄漏，有哪些情况会发生内存泄漏

什么是野指针

怎么编写一个类，使得这个类只能在堆上分配

什么是虚拟内存？虚拟内存的作用

知道哪些进程间通信的方法？

知道哪些进程间互斥的锁？

进程和线程的区别

HTTPS的特性？协商加密的过程？

HTTP2.0的新特性？

TCP如何保证可靠传输？

是否了解红黑树的特点？红黑树的使用场景？

C++文件生成可执行文件的过程

静态链接和动态链接的区别

题目：

1将1000个数装进10个十个抽屉，要求能用不同的抽屉组合出任意1-1000之间的数。

2一个路口观察十分钟有车经过的概率是99%，那么五分钟能观察到有车经过的概率是多少。

3给定一个数组，找出所有的三个数之和为零的组合。
## 数据库
#### Q：数据库的四个隔离级别：
1. 读未提交，Read Uncommited。
指的是一个事务读取到另外一个事务还没有提交的内容。这种情况是必须要避免的。因为其他事务未提交的数据，是随时有可能进行回滚的，所以，任何时候，都不应该允许程序读取到某个事务还未提交的数据。如果读取到了别的事务未提交的数据，这种情况称为脏读。要想解决脏读的问题，可以提高数据库的事务隔离级别，把事务隔离级别设置为读已提交。

2. 读已提交，Read Committed。
这个隔离级别可以解决脏读的问题。
在该隔离级别下，不允许2个未提交的事务之间并行执行，但它允许在一个事务执行的过程中，另外一个事务得到执行并提交。这样，会出现一种情况，第一个事务前后两次select出来的某行数据，值可能不一样。值改变的原因是，穿插执行的事务2对该行数据进行了update操作。在同一个事务中，两次select出来的值不相同的问题称为不可重复读问题。要想解决不可重复读问题，需要把数据的隔离级别设置为可重复读。
3. 可重复读。Repeatable Read。
在这个隔离级别下，可以解决不可重复读的问题。
在该隔离级别下，在一个事务使用某行的数据的过程中，不允许别的事务再对该行数据进行操作。可重复读应该是给数据库的行加上了锁。这种隔离级别下，依旧允许别的事务在该表中插入和删除数据，于是就会出现，在事务1执行的过程中，如果先后两次select出符合某个条件的行，如果在这两次select直接另一个事务得到了执行，insert或delete了某些行，就会出现先后两次select出来的符合同一个条件的结果不一样，第一次select好像出现了幻觉一样，因此，这个问题也被成为幻读。要想解决幻读问题，需要将数据库的隔离级别设置为串行化。

4. 串行化，Serialization。
串行化可以解决幻读的问题。
它要求事务的执行完全串行执行。所以失去了并发的效率。
Mysql的默认隔离级别为可重复读。

总结而言，数据的事务隔离级别分为4种，从低到高依次为读未提交，读已提交，可重复读，串行化。与数据库事务隔离级别相关的问题有3个，分别是脏读，不可重复读，幻读。脏读问题需要用读已提交来解决，但读已提交会存在不可重复读问题。不可重复读问题需要用可重复读来解决，但可重复读会存在幻读问题。幻读问题需要用串行化来解决,但串行化失去了并发的效率。

## 其他
#### Q：编译性语言和解释性语言的区别
 
1. 编译性语言
    - 只须编译一次就可以把源代码编译成机器语言，后面的执行无须重新编译，直接使用之前的编译结果就可以；因此其执行的效率比较高；
    - 编译性语言代表：C、C++、Pascal/Object Pascal（Delphi）；
    - 程序执行效率比较高，但比较依赖编译器，因此跨平台性差一些；
不同平台对编译器影响较大。 
如：*16位系统下int是2个字节（16位），而32位系统下int占4个字节（32位）；32位系统下long类型占4字节，而64位系统下long类型占8个字节；*
2. 解释性语言
    - 源代码不能直接翻译成机器语言，而是先翻译成中间代码，再由解释器对中间代码进行解释运行；
源代码—>中间代码—>机器语言
    - 程序不需要编译，程序在运行时才翻译成机器语言，每执行一次都要翻译一次；
    - 解释性语言代表：Python、JavaScript、Shell、Ruby、MATLAB等；
    - 运行效率一般相对比较低，依赖解释器，跨平台性好；


    

1. 首先根据top命令，发现占用cpu最高的进程PID：3075.

　　通过ps aux | grep PID命令，进一步查看当前进程的具体信息。

2. 显示当前进程下的所有线程列表

　　ps -mp pid -o THREAD,tid,time



找到耗时最高的线程TID，并将其线程ID转换为16进制格式：

　　printf "%x\n" tid



 

3. 打印线程的堆栈信息，thread dump

　　jstack pid |grep tid -A 30

　　进一步分析堆栈信息，就会定位到问题所在



.TCP两次握手可以不？第三次握手可以传输数据吗？
2.TCP缺点？慢启动如何优化
3.进程和线程的区别？进程间通信的方式？有用过哪些？
4.linux有关内存的命令说几个
5.介绍一下fork函数
6.介绍一下recv函数的返回值含义
7.new和malloc的区别
8.多态和虚函数
9.HTTP1.0和1.1的区别？状态码302和404代表什么
10.map的底层实现，map可以用下标进行查找吗？（不可以，count或者find）
11.epoll有几种模式？
12.TCP如何保证有序传输
13.TCP四次挥手中，如果第三次丢失了会怎么办
14.十亿个整数找到其中所有不重复的数（我的回答是分块载入内存进行查找，卑微小嘉在线求解）
15.编程：用字符串s2替换字符串str中子串s1